"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compressQueue = void 0;
const queue_system_1 = require("queue-system");
const errors_js_1 = require("./errors.js");
const compress_js_1 = require("./compress.js");
const noop = () => undefined;
const compressQueue = (options, verbose) => {
    return new Promise((resolve, reject) => {
        let fulfilled = false;
        const errors = [];
        const q = new queue_system_1.Queue({ paused: true, concurrency: options.concurrency });
        options.files.forEach(file => {
            let taskStart = 0;
            const task = q.add(() => {
                taskStart = Date.now();
                if (verbose) {
                    console.warn(`Processing file ${file}`);
                }
                return (0, compress_js_1.compress)({
                    filePath: file,
                    mode: options.mode,
                    quality: options.quality,
                    windowSize: options.windowSize,
                    writeTo: options.printToStdOut ? "stdout" : "file",
                    br: options.br,
                }).finally(() => {
                    if (verbose) {
                        console.warn(`File ${file} processed in ${Date.now() - taskStart}ms`);
                    }
                });
            });
            task.promise.catch(noop);
            task.data = { file };
        });
        q.unpause();
        const taskErrorHandler = (task, error) => {
            const errorData = {
                file: String(task.data.file),
                error: error,
            };
            if (options.bail) {
                fulfilled = true;
                const err = new errors_js_1.CompressionProcessError(`Error happened during compression process`, {
                    list: [errorData],
                });
                reject(err);
                q.destroy();
                return;
            }
            errors.push(errorData);
        };
        q.on(queue_system_1.EVENTS.TASK_ERROR, taskErrorHandler);
        q.on(queue_system_1.EVENTS.QUEUE_SIZE, size => {
            if (fulfilled) {
                return;
            }
            if (size === 0) {
                fulfilled = true;
                if (errors.length) {
                    const err = new errors_js_1.CompressionProcessError(`${errors.length} errors happened during compression process`, {
                        list: errors,
                    });
                    reject(err);
                }
                else {
                    resolve();
                }
                q.destroy();
            }
        });
    });
};
exports.compressQueue = compressQueue;
//# sourceMappingURL=compressQueue.js.map