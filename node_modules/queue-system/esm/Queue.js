import EventEmitter from "eventemitter3";
import { ensureError, pull } from "@ezez/utils";
import { Task } from "./Task.js";
import { EVENTS } from "./const.js";
import { isThenable } from "./isThenable.js";
const knownEvents = Object.values(EVENTS);
class Queue {
    constructor(options = {}) {
        this._tasks = [];
        this._runningTasks = [];
        this._destroyed = false;
        this._paused = false;
        this._concurrency = (options.concurrency > 0) ? options.concurrency : 1;
        this.push = this.add;
        this.unshift = this.prepend;
        this._paused = Boolean(options.paused);
        this._ee = (new EventEmitter());
        this.on = this.addEventListener;
        this.off = this.removeEventListener;
        this.once = this.addEventListenerOnce;
    }
    _destroyedCheck() {
        if (this._destroyed) {
            throw new Error("This queue is destroyed");
        }
    }
    destroy() {
        this._destroyedCheck();
        this._destroyed = true;
        this._ee.removeAllListeners();
        const tasksToRemove = this._tasks.filter((task) => {
            return !this.isTaskRunning(task);
        });
        tasksToRemove.forEach(task => { this._remove(task); });
        return {
            removed: tasksToRemove,
            inProgress: [...this._runningTasks],
        };
    }
    _runNext() {
        if (this._paused) {
            return;
        }
        while (this._isConcurrencySlotFree()) {
            const taskToRun = this._tasks.find((task) => {
                return !this.isTaskRunning(task);
            });
            if (taskToRun) {
                taskToRun.run();
            }
            else {
                break;
            }
        }
    }
    _isConcurrencySlotFree() {
        return this._runningTasks.length < this._concurrency;
    }
    _createTask(taskFn, data) {
        const run = async (isCancelled, cancelPromise) => {
            this._ee.emit(EVENTS.TASK_START, task);
            this._runningTasks.push(task);
            const end = (event, result) => {
                this._ee.emit(EVENTS.TASK_END, task, result);
                this._ee.emit(event, task, result);
                this._remove(task);
                this._removeRunning(task);
                this._runNext();
            };
            try {
                const taskPromise = taskFn(isCancelled, cancelPromise);
                if (isThenable(taskPromise)) {
                    return taskPromise.then((result) => {
                        end(EVENTS.TASK_SUCCESS, result);
                        return result;
                    }, (error) => {
                        const err = ensureError(error);
                        end(EVENTS.TASK_ERROR, err);
                        throw err;
                    });
                }
                end(EVENTS.TASK_SUCCESS, taskPromise);
                return Promise.resolve(taskPromise);
            }
            catch (e) {
                const err = ensureError(e);
                end(EVENTS.TASK_THROWN, err);
                return Promise.reject(err);
            }
        };
        const task = new Task(this, run, () => this._destroyed);
        if (data != null) {
            task.data = data;
        }
        return task;
    }
    addEventListener(eventName, fn) {
        this._destroyedCheck();
        if (!knownEvents.includes(eventName)) {
            throw new Error("Unknown event");
        }
        this._ee.on(eventName, fn);
        return () => {
            this.removeEventListener(eventName, fn);
        };
    }
    addEventListenerOnce(eventName, fn) {
        this._destroyedCheck();
        if (!knownEvents.includes(eventName)) {
            throw new Error("Unknown event");
        }
        this._ee.once(eventName, fn);
        return () => {
            this.removeEventListener(eventName, fn);
        };
    }
    removeEventListener(eventName, fn) {
        this._destroyedCheck();
        if (!knownEvents.includes(eventName)) {
            throw new Error("Unknown event");
        }
        this._ee.off(eventName, fn);
    }
    setConcurrency(concurrency) {
        this._destroyedCheck();
        this._concurrency = concurrency;
        this._runNext();
    }
    add(taskFn, data) {
        this._destroyedCheck();
        const task = this._createTask(taskFn, data);
        this._tasks.push(task);
        this._ee.emit(EVENTS.TASK_ADD, task);
        this._ee.emit(EVENTS.QUEUE_SIZE, this.getQueueSize());
        this._ee.emit(EVENTS.QUEUE_ORDER, this.getTasks());
        this._runNext();
        return task;
    }
    prepend(taskFn, data) {
        this._destroyedCheck();
        const task = this._createTask(taskFn, data);
        this._tasks.unshift(task);
        this._ee.emit(EVENTS.TASK_ADD, task);
        this._ee.emit(EVENTS.QUEUE_SIZE, this.getQueueSize());
        this._ee.emit(EVENTS.QUEUE_ORDER, this.getTasks());
        this._runNext();
        return task;
    }
    insertAt(taskFn, index, data) {
        this._destroyedCheck();
        const task = this._createTask(taskFn, data);
        this._tasks.splice(index, 0, task);
        this._ee.emit(EVENTS.TASK_ADD, task);
        this._ee.emit(EVENTS.QUEUE_SIZE, this.getQueueSize());
        this._ee.emit(EVENTS.QUEUE_ORDER, this.getTasks());
        this._runNext();
        return task;
    }
    remove(task) {
        this._destroyedCheck();
        this._remove(task);
    }
    _remove(task) {
        const lengthBefore = this._tasks.length;
        pull(this._tasks, task);
        if (this._tasks.length === lengthBefore) {
            throw new Error("Task not found in queue");
        }
        this._ee.emit(EVENTS.TASK_REMOVE, task);
        this._ee.emit(EVENTS.QUEUE_SIZE, this.getQueueSize());
        this._ee.emit(EVENTS.QUEUE_ORDER, this.getTasks());
    }
    _removeRunning(task) {
        pull(this._runningTasks, task);
    }
    getQueueSize() {
        return this._tasks.length;
    }
    getTasks() {
        return [...this._tasks];
    }
    filter(fn) {
        return this._tasks.filter(task => {
            const isRunning = this.isTaskRunning(task);
            const isCancelled = task.isCancelled();
            return fn(task.data, isRunning, isCancelled);
        });
    }
    cancelBy(fn) {
        const tasks = this.filter(fn);
        tasks.forEach(task => { task.cancel(); });
        return tasks;
    }
    getTaskPosition(task) {
        return this._tasks.findIndex(t => t === task);
    }
    getTaskWaitingPosition(task) {
        return this._tasks.filter(t => !t.isRunning()).findIndex(t => t === task);
    }
    isTaskRunning(task) {
        return this._runningTasks.includes(task);
    }
    pause() {
        this._paused = true;
    }
    unpause() {
        this._paused = false;
        this._runNext();
    }
}
export { Queue, };
//# sourceMappingURL=Queue.js.map