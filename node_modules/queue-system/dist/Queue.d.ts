import type { FilterFn, QueueOptions, TaskFn, QueueDestroyInfo } from "./types";
import type { EventsTypes } from "./const.js";
import { Task } from "./Task.js";
import { EVENTS } from "./const.js";
declare class Queue {
    private _concurrency;
    private readonly _tasks;
    private readonly _runningTasks;
    private readonly _ee;
    private _destroyed;
    private _paused;
    push: typeof Queue.prototype.add;
    unshift: typeof Queue.prototype.prepend;
    readonly on: typeof Queue.prototype.addEventListener;
    readonly off: typeof Queue.prototype.removeEventListener;
    readonly once: typeof Queue.prototype.addEventListenerOnce;
    constructor(options?: QueueOptions);
    private _destroyedCheck;
    destroy(): QueueDestroyInfo;
    private _runNext;
    private _isConcurrencySlotFree;
    private _createTask;
    addEventListener<T extends EVENTS>(eventName: T, fn: EventsTypes[T]): () => void;
    addEventListenerOnce<T extends EVENTS>(eventName: T, fn: EventsTypes[T]): () => void;
    removeEventListener<T extends EVENTS>(eventName: T, fn: EventsTypes[T]): void;
    setConcurrency(concurrency: number): void;
    add<ReturnValue>(taskFn: TaskFn<ReturnValue>, data?: {
        [key: string]: unknown;
    }): Task<ReturnValue>;
    prepend<V>(taskFn: TaskFn<V>, data?: {
        [key: string]: unknown;
    }): Task<V>;
    insertAt<V>(taskFn: TaskFn<V>, index: number, data?: {
        [key: string]: unknown;
    }): Task<V>;
    remove<V>(task: Task<V>): void;
    private _remove;
    private _removeRunning;
    getQueueSize(): number;
    getTasks(): Task<any>[];
    filter(fn: FilterFn): Task<any>[];
    cancelBy(fn: FilterFn): Task<any>[];
    getTaskPosition<V>(task: Task<V>): number;
    getTaskWaitingPosition<V>(task: Task<V>): number;
    isTaskRunning<V>(task: Task<V>): boolean;
    pause(): void;
    unpause(): void;
}
export { Queue, };
//# sourceMappingURL=Queue.d.ts.map