"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.throttle = void 0;
const defaultOptions = {
    leading: true,
    trailing: true,
};
const throttle = (fn, time = 0, options) => {
    var _a, _b;
    const opts = {
        leading: (_a = options === null || options === void 0 ? void 0 : options.leading) !== null && _a !== void 0 ? _a : defaultOptions.leading,
        trailing: (_b = options === null || options === void 0 ? void 0 : options.trailing) !== null && _b !== void 0 ? _b : defaultOptions.trailing,
    };
    if (!opts.trailing && !opts.leading) {
        throw new TypeError("Throttle with trailing & leading options `false` won't do anything.");
    }
    if (typeof time !== "number" && !time.length) {
        throw new TypeError("`time` must be an array with at least one number.");
    }
    const finalTime = typeof time === "number" ? time : time[time.length - 1];
    let lastRun = 0, timeoutId = null, lastResult, lastArgs, lastTime = typeof time === "number" ? time : time[0], leadingCalled = false;
    const times = typeof time === "number" ? [time] : [...time];
    const throttledFn = ((...args) => {
        var _a, _b, _c;
        lastArgs = args;
        if (timeoutId !== null) {
            return lastResult;
        }
        if (!opts.trailing) {
            if (Date.now() - lastRun < lastTime) {
                return lastResult;
            }
            lastTime = (_a = times.shift()) !== null && _a !== void 0 ? _a : finalTime;
            lastRun = Date.now();
            lastResult = fn(...args);
            return lastResult;
        }
        const diffLastRun = Date.now() - lastRun;
        if (opts.leading && (!leadingCalled || typeof time === "number") && diffLastRun >= ((_b = times[0]) !== null && _b !== void 0 ? _b : finalTime)) {
            lastRun = Date.now();
            lastResult = fn(...args);
            leadingCalled = true;
            return lastResult;
        }
        if (lastRun || !opts.leading) {
            lastTime = (_c = times.shift()) !== null && _c !== void 0 ? _c : finalTime;
        }
        timeoutId = setTimeout(() => {
            timeoutId = null;
            lastRun = Date.now();
            lastResult = fn(...args);
        }, lastRun ? (lastTime - diffLastRun + 1) : lastTime);
        return lastResult;
    });
    throttledFn.cancel = () => {
        timeoutId !== null && clearTimeout(timeoutId);
        timeoutId = null;
        lastRun = 0;
        lastResult = undefined;
        times.length = 0;
        if (typeof time === "number") {
            times.push(time);
        }
        else {
            times.push(...time);
        }
        lastTime = typeof time === "number" ? time : time[0];
    };
    throttledFn.flush = () => {
        if (timeoutId !== null) {
            lastRun = Date.now();
            lastResult = fn(...lastArgs);
            clearTimeout(timeoutId);
            timeoutId = null;
            return throttledFn(...lastArgs);
        }
        return lastResult;
    };
    return throttledFn;
};
exports.throttle = throttle;
//# sourceMappingURL=throttle.js.map