type Names = (string | Names)[];
type Data = Record<string, unknown>;
type Nullable<T> = T | null | undefined;
interface CustomError<D extends Data> extends Error {
    details?: D;
    parent?: CustomError<Data> | Error;
    ancestors: (CustomError<Data> | Error)[];
    names: Names;
}
type Arg<D extends Data> = Error | CustomError<D> | string | D | undefined | null;
interface CustomErrorConstructor2<D extends Data> {
    new (arg1?: Nullable<string>, arg2?: Nullable<D>, arg3?: Nullable<Error>): CustomError<D>;
    (arg1?: Nullable<string>, arg2?: Nullable<D>, arg3?: Nullable<Error>): CustomError<D>;
    stackTraceLimit: ErrorConstructor["stackTraceLimit"];
    captureStackTrace: ErrorConstructor["captureStackTrace"];
    extend: <D2 extends D>(name: string, options?: Options) => CustomErrorConstructor<D2>;
    normalize: (maybeError: unknown, options?: NormalizeOptions) => CustomError<D> | Error;
    prototype: CustomError<D>;
}
type CustomErrorConstructor<D extends Data> = CustomErrorConstructor2<D>;
interface Options {
    cleanStackTraces?: boolean;
}
interface NormalizeOptions {
    mode: "instanceof" | "strict" | "loose";
}
export type { Options, Names, Nullable, Data, Arg, CustomError, CustomErrorConstructor, NormalizeOptions };
//# sourceMappingURL=types.d.ts.map